{"version":3,"file":"main.a3dbf6ff2222f0c896cc.bundle.js","sources":["webpack:///../ibm-gantt-chart/src/core/core.js"],"sourcesContent":["import 'font-awesome/css/font-awesome.css';\n\n/* eslint-disable */\nimport './core.scss';\nimport './fonts.scss';\n\nexport default class Gantt {\n  constructor(context, config) {\n    this.context = Gantt.utils.isString(context) ? document.getElementById(context) : context;\n    const panelClass = Gantt.components.GanttPanel.impl || Gantt.components.GanttPanel;\n    this.gantt = new panelClass(this.context, config);\n    return this.gantt;\n  }\n}\n\nGantt.defaultConfiguration = {\n  rowHeight: 27,\n  zoomFactor: 0.2,\n  loadingPanelThresold: 500,\n};\n\n// noinspection SpellCheckingInspection\nGantt.events = {\n  TITLE_CHANGED: 'titleChanged',\n  TABLE_INIT: 'tableinit',\n  TIME_TABLE_INIT: 'timesheetinit',\n  TIME_LINE_INIT: 'timeline_init',\n  TIME_WINDOW_CHANGED: 'timeWindowChanged',\n  TIME_LINE_RANGE_CHANGE: 'timeline_rangechange',\n  TIME_LINE_RANGE_CHANGED: 'timeline_rangechanged',\n  TIME_LINE_SIZE_CHANGED: 'timeline_sizeChanged',\n  TIME_LINE_PAN_MOVE: 'timeline_panmove',\n  TIME_LINE_PAN_MOVED: 'timeline_panmove',\n  TIME_LINE_SCROLLED: 'timeline_scrolled',\n  RESIZED: 'resized',\n  SPLIT_RESIZED: 'split_resized',\n  ROWS_FILTERED: 'rows_filtered',\n  DATA_LOADED: 'data_loaded',\n  ROWS_ADDED: 'rows_added',\n  ROWS_REMOVED: 'rows_removed',\n  ROWS_MODIFIED: 'rows_modified',\n  ROWS_SORTED: 'rows_sorted',\n\n  START_SELECTING: 'startSelecting',\n  SELECTION_CLEARED: 'selectionCleared',\n  STOP_SELECTING: 'stopSelecting',\n\n  // Event names are generated from the Type objects associated with the SelectionHandler, with the format type.name + 'Selected|Unselected|SelectionChanged|SelectionCleared'\n  ACTIVITY_SELECTED: 'activitySelected',\n  ACTIVITY_UNSELECTED: 'activityUnselected',\n  ACTIVITY_SELECTION_CHANGED: 'activitySelectionChanged',\n  ACTIVITY_SELECTION_CLEARED: 'activitySelectionCleared',\n\n  RESOURCE_SELECTED: 'resourceSelected',\n  RESOURCE_UNSELECTED: 'resourceUnselected',\n  RESOURCE_SELECTION_CHANGED: 'resourceSelectionChanged',\n  RESOURCE_SELECTION_CLEARED: 'resourceSelectionCleared',\n\n  ROW_SELECTED: 'rowSelected',\n  ROW_UNSELECTED: 'rowUnselected',\n  ROW_SELECTION_CHANGED: 'rowSelectionChanged',\n  ROW_SELECTION_CLEARED: 'rowSelectionCleared',\n\n  CONSTRAINT_SELECTED: 'constraintSelected',\n  CONSTRAINT_UNSELECTED: 'constraintUnselected',\n  CONSTRAINT_SELECTION_CHANGED: 'constraintSelectionChanged',\n  CONSTRAINT_SELECTION_CLEARED: 'constraintSelectionCleared',\n};\n\nGantt.type = {\n  ACTIVITY_CHART: 'ActivityChart',\n  SCHEDULE_CHART: 'ScheduleChart',\n};\n\nGantt.constraintTypes = {\n  START_TO_START: 0,\n  START_TO_END: 2,\n  END_TO_END: 3,\n  END_TO_START: 1,\n  isFromStart(type) {\n    return type === 0 || type === 2;\n  },\n  isToStart(type) {\n    return type < 2;\n  },\n};\n\nclass Tooltip {\n  constructor(config) {}\n  showTooltip(elt, ctx, cb) {}\n  hideTooltip() {}\n  destroy() {}\n}\n\nclass DataFetcher {\n  get(obj) {}\n}\n\nclass Split {\n  constructor(elt, config) {}\n  getLeftComponent() {}\n  getRightComponent() {}\n  leftComponentCreated() {}\n}\n\nclass Component {\n  constructor(gantt, config) {\n    this.gantt = gantt;\n    this.config = config;\n    this.utils = Gantt.utils;\n  }\n\n  on(event, handler) {\n    let events = this.__events || (this.__events = {});\n    let ar;\n    let eventList = (this.utils.isArray(event) && event) || event.split(' ');\n    for (let i = 0; i < eventList.length; i++) {\n      event = eventList[i];\n      if (!(ar = events[event])) {\n        events[event] = ar = [handler];\n      } else {\n        ar.push(handler);\n      }\n    }\n  }\n\n  one(events, handler) {\n    const wrapperHandler = (...params) => {\n      handler.apply(this, params);\n      // remove the handler after it has been notified\n      const event = params[0];\n      const index = this.__events[event].indexOf(wrapperHandler);\n      if (index > -1) {\n        this.__events[event].splice(index, 1);\n      }\n    };\n    this.on(events, wrapperHandler);\n  }\n\n  off(event, handler) {\n    if (this.__events) {\n      let ar, i;\n      let eventList = (this.utils.isArray(event) && event) || event.split(' ');\n      for (let iEvent = 0; iEvent < eventList.length; iEvent++) {\n        event = eventList[iEvent];\n        if ((ar = this.__events[event])) {\n          for (i = 0; i < ar.length; i++) {\n            if (ar[i] === handler) {\n              ar.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  triggerEvent(events) {\n    let ar, params;\n    if (events === true) {\n      // Apply mode, event parameters are provided as an array\n      events = arguments[1];\n      const paramsArg = arguments[2] || [];\n      params = new Array(paramsArg.length + 1);\n      for (let iParam = 0; iParam < paramsArg.length; ++iParam) {\n        params[iParam + 1] = paramsArg[iParam];\n      }\n    } else {\n      params = new Array(arguments.length);\n      for (let iParam = 1; iParam < arguments.length; ++iParam) {\n        params[iParam] = arguments[iParam];\n      }\n    }\n\n    const eventList = (this.utils.isArray(events) && events) || events.split(' ');\n    for (let iEvent = 0, event, evCount = eventList.length; iEvent < evCount; iEvent++) {\n      if ((ar = this.__events && this.__events[(params[0] = event = eventList[iEvent])])) {\n        for (let i = 0, count = ar.length; i < count; ) {\n          ar[i].apply(this, params);\n          // If the handler being notified still in the array, go to next array elt\n          if (count === ar.length) {\n            ++i;\n          } else {\n            // If the handler was removed during notification (see one method), next element is at same index\n            count = ar.length;\n          }\n        }\n      }\n    }\n  }\n}\n\nclass ErrorHandler extends Component {\n  constructor(config) {\n    super(null, config);\n    this.config = config;\n  }\n\n  addError(err) {}\n\n  hasErrors() {\n    return false;\n  }\n\n  clear() {}\n\n  showError(err) {}\n\n  getErrors() {\n    return [];\n  }\n\n  createErrorNode(err) {\n    const node = document.createElement('div');\n    node.className = 'gantt_error';\n    return node;\n  }\n\n  removeGroup(node) {}\n}\n\n/**\n *\n * <br>Emmits events: <ul>\n *   <li>Gantt.events.TIME_LINE_INIT</li>\n *   <li>Gantt.events.TIME_LINE_RANGE_CHANGE</li>\n *   <li>Gantt.events.TIME_LINE_RANGE_CHANGED</li>\n *   <li>Gantt.events.TIME_LINE_PAN_MOVED</li>\n *   <li>Gantt.events.TIME_LINE_SIZE_CHANGED</li>\n * </ul>\n */\nclass TimeLine extends Component {\n  constructor(gantt, node, config) {\n    super(gantt, config);\n    this.node = node;\n  }\n\n  setTimeWindow(start, end) {}\n\n  getTimeAxisHeight() {\n    return 0;\n  }\n\n  draw() {}\n\n  validateZoomFactor(zoomFactor) {}\n\n  getXFromMillis(time) {}\n\n  getDecorationContainer() {}\n\n  /**\n   * Returns the current time horizon, an object with two start and end time properties, time given in milliseconds\n   */\n  getHorizon() {}\n\n  getScrollableHorizon() {}\n\n  setVisibleTimeWindow(window) {}\n\n  resetZoom() {}\n\n  /**\n   * Markers\n   */\n  addTimeMarker(id, time, classes) {}\n\n  removeTimeMarker(id) {}\n\n  setTimeLineItem(id, item) {}\n\n  addTimeLineItem(id, item) {}\n\n  removeTimeLineItem(id) {}\n}\n\nclass TimeTable extends Component {\n  constructor(gantt, node, config) {\n    super(gantt, config);\n    this.node = node;\n    this.setConfiguration(config);\n  }\n  setConfiguration(config) {}\n\n  draw() {}\n\n  createUpdates(parent) {\n    return new (Gantt.components.GanttUpdates.impl || Gantt.components.GanttUpdates)(parent);\n  }\n\n  highlightRow(row, highlight, deselectAll) {}\n\n  getDisplayedActivitiesTimeRange() {}\n\n  searchActivities(row, callback) {}\n\n  setConstraints(constraints) {}\n\n  update() {}\n\n  scrollToRow(row) {}\n\n  scrollToY(y) {}\n\n  setScrollTop(y) {}\n\n  setFirstVisibleRow(row) {}\n\n  getScrollLeft() {}\n  setScrollLeft(x) {}\n\n  /**\n   * Returns the component responsible for scrolling the time table.\n   */\n  getScroller() {}\n  getVisibleWidth() {}\n  getVisibleHeight() {}\n\n  // Called to adjust the time table body width according to the time line width\n  setBodyWidth(w) {}\n  getBodyWidth() {}\n\n  // Called to adjust the height of the time  table body according to the height of the gantt table\n  setBodyHeight(h) {}\n  getBodyHeight() {}\n\n  // To perfectly horizontally align the time line and the time table, we need to apply a right margin\n  // to the time line corresponding to the width of the vertical scroller in the time table, if any.\n  getRightMargin() {}\n\n  // The time line bottom must stops where the horizontal scrollbar of the time table starts.\n  // The getBottomMargin returns the height of this scrollbar.\n  getBottomMargin() {}\n}\n\n/**\n *\n * <br>Emmits events: <ul>\n *   <li>Gantt.events.TABLE_INIT</li>\n *   <li>Gantt.events.ROWS_ADDED</li>\n *   <li>Gantt.events.ROWS_REMOVED</li>\n *   <li>Gantt.events.ROWS_MODIFIED</li>\n *   <li>Gantt.events.ROWS_FILTERED</li>\n * </ul>\n */\nclass TreeTable extends Component {\n  constructor(gantt, node, config) {\n    super(gantt, config);\n    this.node = node;\n  }\n\n  setRows(rows) {}\n\n  getRowCount() {\n    return 0;\n  }\n\n  isRowVisible(param) {}\n\n  deleteDrawCache() {}\n\n  draw() {}\n\n  drawRows(selector) {}\n\n  createUpdates(parent) {\n    return new (Gantt.components.GanttUpdates.impl || Gantt.components.GanttUpdates)(parent);\n  }\n\n  highlightRow(row, highlight, deselectAll) {}\n\n  setRowFilter(filter) {}\n\n  filterChanged() {}\n\n  isRowFiltered(row) {\n    return false;\n  }\n\n  toggleCollapseRow(param, collapse) {}\n\n  setHeaderHeight(height) {}\n\n  getTableBody() {}\n\n  getScrollableTable() {}\n\n  getTop(tr) {\n    return (tr && tr.offsetTop - this.getTableBody().offsetTop) || 0;\n  }\n\n  getRowAt(y) {}\n\n  getHeight() {}\n\n  nextRow(row) {\n    return null;\n  }\n\n  getRow(id) {\n    return null;\n  }\n\n  getRows(selector) {}\n\n  getRowName(row) {\n    return row.name;\n  }\n\n  getRowTop(row) {\n    return (row.tr && row.tr.offsetTop - this.getTableBody().offsetTop) || 0;\n  }\n\n  expandParents(row) {}\n}\n\nTreeTable.defaultClass = '';\n\nclass GanttModel extends Component {\n  constructor(gantt, config) {\n    super(gantt, config);\n    if (config) {\n      this.setConfiguration(config);\n    }\n  }\n\n  setConfiguration(config) {}\n}\n\n/**\n *\n * <br>Emmits events: <ul>\n *   <li>Gantt.events.TABLE_INIT</li>\n *   <li>Gantt.events.ROWS_ADDED</li>\n *   <li>Gantt.events.ROWS_REMOVED</li>\n *   <li>Gantt.events.ROWS_MODIFIED</li>\n *   <li>Gantt.events.ROWS_FILTERED</li>\n * </ul>\n */\nclass GanttPanel extends Component {\n  constructor(node, config) {\n    super(node, config);\n    this.node = node;\n    this.events = Gantt.events;\n    this.constraintTypes = Gantt.constraintTypes;\n  }\n\n  setConfiguration(config) {}\n\n  draw() {}\n\n  startUpdating() {}\n\n  stopUpdating() {}\n\n  getModel() {}\n\n  getRowCount() {\n    return 0;\n  }\n\n  getRow(param) {\n    return null;\n  }\n\n  getVisiibleRows() {\n    return [];\n  }\n\n  ensureRowVisible(param) {}\n\n  isRowVisible(param) {}\n\n  getFirstVisibleRow() {}\n\n  setFirstVisibleRow(row) {}\n\n  isRowFiltered(param) {}\n\n  toggleCollapseRow(param, collapse) {}\n\n  scrollToY(y) {}\n\n  getRowActivities(param) {}\n\n  resetZoom() {}\n\n  zoomIn(evt) {}\n\n  zoomOut(evt) {}\n\n  zoom(zoomFactor, evt) {}\n\n  fitToContent() {}\n\n  getVisibleHeight() {\n    return 0;\n  }\n\n  highlightRow(row, highlight, deselectAll) {}\n\n  /*                        */\n  /*    Search and filter   */\n  /*                        */\n  addFilter(rowFilter, rows, activities) {}\n\n  addFilter(rowFilter, filterTasks) {}\n\n  removeFilter(key, preventNotify) {}\n\n  search(text, rows, activities) {}\n\n  setHideEmptyRows(hide, preventNotify) {}\n\n  /*                        */\n  /*          Utils         */\n  /*                        */\n}\n\nclass Filter {\n  constructor(options) {}\n}\n\nclass Renderer {\n  constructor(config, proto, paletteHandler) {\n    if (proto) {\n      Gantt.utils.mergeObjects(this, proto);\n    }\n    this.config = config;\n    this.paletteHandler = paletteHandler;\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {}\n}\n\nclass ActivityLayout {\n  constructor(config) {}\n\n  layout(row) {}\n\n  allowVariableRowHeight() {\n    return false;\n  }\n}\n\nGantt.ObjectTypes = {\n  Activity: 2,\n  Resource: 4,\n  Row: 1,\n  Constraint: 8,\n  Reservation: 16,\n};\n\nclass SelectionHandler extends Component {\n  constructor(config, proto) {\n    super(null, config);\n    this.selections = [];\n    this.selectionType = null;\n    if (proto) {\n      Gantt.utils.mergeObjects(this, proto);\n    }\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {}\n\n  getObjectType(obj) {}\n\n  select(obj, clear, notActive) {}\n\n  clearSelection() {\n    this.selections = [];\n  }\n\n  isSelected(obj) {\n    return this.selections.indexOf(obj) >= 0;\n  }\n\n  processClick(e, obj) {}\n\n  destroy() {\n    this.selections = [];\n  }\n}\n\nclass LayoutSynchronizer extends Component {\n  constructor(config, proto) {\n    super(null, config);\n    if (proto) {\n      Gantt.utils.mergeObjects(this, proto || config);\n    }\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {}\n\n  connect(gantt) {}\n\n  disconnect() {}\n\n  destroy() {\n    this.disconnect();\n  }\n}\n\nclass Palette {\n  constructor(config) {}\n  getColors(count) {}\n}\n\nGantt.defaultPaletteName = null;\nGantt.defaultPalettes = {};\n\nclass GanttUpdates {\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  addUpdate(update) {}\n\n  removeUpdate(update) {}\n\n  reload() {\n    this._reload = true;\n  }\n  isReload() {\n    return false;\n  }\n  destroy() {}\n  startUpdating() {}\n  stopUpdating() {}\n}\n\nclass Toolbar extends Component {\n  constructor(gantt, node, config) {\n    super(gantt, config);\n    this.node = node;\n    this.setConfiguration(config, node);\n  }\n\n  setConfiguration(config, node) {\n    this.config = config;\n  }\n\n  connect(gantt) {}\n\n  ganttLoaded(gantt, rows) {}\n\n  onInitialized() {}\n\n  destroy() {}\n}\n\nToolbar.createTitle = function(title) {\n  const node = document.createElement('div');\n  node.innerHTML = title;\n  node.className = 'toolbar-title';\n  return node;\n};\n\nclass Button extends Component {\n  constructor(gantt, config) {\n    super(gantt, config);\n    this.callbacks = [];\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {\n    const btn = document.createElement('div');\n    if (config.id) {\n      btn.id = config.id;\n    }\n    btn.className = `toolbar-button g-hoverable g-selectable${config.classes ? ' ' + config.classes : ''}`;\n    if (config.icon) {\n      const img = document.createElement('img');\n      img.src = config.icon;\n      img.alt = '';\n      btn.appendChild(img);\n    }\n    if (config.fontIcon) {\n      const fontIcon = document.createElement('i');\n      fontIcon.className = config.fontIcon + (config.text ? ' fa-fw' : '');\n      btn.appendChild(fontIcon);\n    }\n    if (config.svg) {\n      Gantt.utils.appendSVG(btn, config.svg);\n    }\n    if (config.text) {\n      btn.appendChild(document.createTextNode(config.text));\n    }\n    this.node = btn;\n    this.node.onclick = e => {\n      this.clicked(e);\n      this.callbacks.map(cb => {\n        cb({ gantt: this.gantt, event: e });\n      });\n    };\n    if (config.onclick) {\n      this.onclick(config.onclick);\n    }\n    return btn;\n  }\n\n  onclick(callback) {\n    this.callbacks.push(callback);\n  }\n\n  clicked(e) {}\n\n  setId(id) {\n    this.node.id = id;\n  }\n\n  update() {}\n\n  setSelected(selected) {\n    Gantt.utils.toggleClass(this.node, 'selected', selected);\n  }\n}\n\nclass CheckBox extends Component {\n  constructor(gantt, config) {\n    super(gantt, config);\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {\n    const ctnr = (this.node = document.createElement('div'));\n    ctnr.style.whiteSpace = 'nowrap';\n    const input = (this.inputNode = document.createElement('input'));\n    input.setAttribute('type', 'checkbox');\n    input.setAttribute('value', 'None');\n    input.className = 'g-selectable g-hoverable';\n    if (config.id) {\n      input.id = id;\n    }\n    if (config.classes) {\n      ctnr.className = config.classes;\n    }\n    ctnr.appendChild(input);\n    const label = document.createElement('label');\n    if (config.id) {\n      label.setAttribute('for', config.id);\n    }\n    if (config.icon) {\n      const img = document.createElement('img');\n      img.src = config.icon;\n      img.alt = '';\n      label.appendChild(img);\n    }\n    if (config.svg) {\n      Gantt.utils.appendSVG(label, config.svg);\n    }\n    if (config.text) {\n      label.appendChild(document.createTextNode(config.text));\n    }\n    if (config.onclick) {\n      this.onclick(config.onclick);\n    }\n    ctnr.appendChild(label);\n    return ctnr;\n  }\n\n  setChecked(checked) {\n    this.inputNode.checked = checked;\n  }\n\n  onclick(callback) {\n    this.inputNode.onclick = e => {\n      callback(this.inputNode.checked, { gantt: this.gantt, event: e });\n    };\n  }\n\n  update() {}\n\n  setId(id) {\n    this.inputNode.id = id;\n  }\n}\n\nCheckBox.defaultClass = null;\n\nclass Toggle extends Component {\n  constructor(gantt, config) {\n    super(gantt, config);\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {\n    this.callbacks = [];\n    const ctnr = (this._node = document.createElement('div'));\n    this._isSel = config.isSelected && config.isSelected(this.gantt);\n    this.btnUnselected = new (Gantt.components.Button.impl || Gantt.components.Button)(this.gantt, config.unselected);\n    this.btnSelected = new (Gantt.components.Button.impl || Gantt.components.Button)(this.gantt, config.selected);\n    ctnr.appendChild(this._isSel ? this.btnSelected.node : this.btnUnselected.node);\n    if (config.id) {\n      ctnr.id = id;\n    }\n    const onclick = e => {\n      this._isSel = !this._isSel;\n      this.updateButtons(this._isSel);\n      this.callbacks.forEach(c => {\n        c(this._isSel, { gantt: this.gantt, event: e });\n      });\n    };\n    this.btnUnselected.node.onclick = this.btnSelected.node.onclick = onclick;\n    if (config.onclick) {\n      this.onclick(config.onclick);\n    }\n    return ctnr;\n  }\n\n  isSelected() {\n    return this._isSel;\n  }\n\n  setSelected(selected) {\n    this._isSel = selected;\n    this.updateButtons(selected);\n  }\n\n  get node() {\n    return this._node;\n  }\n\n  set node(node) {\n    this._node = node;\n  }\n\n  onclick(callback) {\n    this.callbacks.push(callback);\n  }\n\n  update() {\n    this.updateButtons(this.config.isSelected ? (this._isSel = this.config.isSelected(this.gantt)) : this._isSel);\n  }\n\n  updateButtons(isSel) {\n    if (this.btnSelected.node.parentNode) {\n      if (!isSel) this._node.replaceChild(this.btnUnselected.node, this.btnSelected.node);\n    } else if (this.btnUnselected.node.parentNode) {\n      this._node.replaceChild(this.btnSelected.node, this.btnUnselected.node);\n    }\n  }\n}\n\nToggle.defaultClass = null;\n\nclass DropDownList extends Component {\n  constructor(gantt, config) {\n    super(gantt, config);\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {\n    const node = (this.node = document.createElement('div'));\n    const defaultClass = DropDownList.defaultClass;\n    if (defaultClass) {\n      node.className = defaultClass;\n    }\n    if (config.classes) {\n      Gantt.utils.addClass(node, config.classes);\n    }\n    if (config.text || config.icon || config.fontIcon) {\n      const labelNode = document.createElement('div');\n      labelNode.className = 'label';\n      if (config.icon) {\n        const img = document.createElement('img');\n        img.src = config.icon;\n        img.alt = '';\n        labelNode.appendChild(img);\n      }\n      if (config.fontIcon) {\n        const fontIcon = document.createElement('i');\n        fontIcon.className = config.fontIcon + (config.text ? ' fa-fw' : '');\n        labelNode.appendChild(fontIcon);\n      }\n      if (config.text) {\n        labelNode.appendChild(document.createTextNode(config.text));\n      }\n      node.appendChild(labelNode);\n    }\n    const select = (this.selectNode = document.createElement('select'));\n    select.className = 'g-hoverable';\n    for (let i = 0, count = config.options.length, opt, optNode; i < count; i++) {\n      opt = config.options[i];\n      optNode = document.createElement('option');\n      optNode.text = opt.text;\n      optNode.value = opt.value;\n      select.appendChild(optNode);\n    }\n    node.appendChild(select);\n    if (config.onchange) {\n      this.onchange(config.onchange);\n    }\n    return node;\n  }\n\n  select(value) {\n    this.selectNode.value = value;\n  }\n\n  onchange(callback) {\n    this.selectNode.onchange = e => {\n      callback(this.selectNode.value, { gantt: this.gantt, event: e });\n    };\n  }\n\n  update() {}\n\n  setId(id) {\n    this.selectNode.id = id;\n  }\n}\n\nDropDownList.defaultClass = 'dropdown-list';\n\nclass Input extends Component {\n  constructor(gantt, config) {\n    super(gantt, config);\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {\n    const node = (this.node = document.createElement('div'));\n    if (Input.defaultClass) {\n      node.className = Input.defaultClass;\n    }\n    if (config.classes) {\n      Gantt.utils.addClass(node, config.classes);\n    }\n    node.style.display = 'flex';\n    node.style.flexDirection = 'row';\n    node.style.alignItems = 'center';\n\n    if (config.text || config.icon || config.fontIcon || config.type === 'search') {\n      const labelNode = document.createElement('div');\n      labelNode.className = 'label';\n      labelNode.style.display = 'inline-block';\n      if (config.icon) {\n        const img = document.createElement('img');\n        img.src = config.icon;\n        img.alt = '';\n        labelNode.appendChild(img);\n      }\n      if (config.fontIcon) {\n        const fontIcon = document.createElement('i');\n        fontIcon.className = config.fontIcon + (config.text ? ' fa-fw' : '');\n        fontIcon.setAttribute('aria-disabled', true);\n        labelNode.appendChild(fontIcon);\n      } else if (config.type === 'search') {\n        const fontIcon = document.createElement('i');\n        fontIcon.setAttribute('aria-disabled', true);\n        fontIcon.className = `fa fa-search fa-lg${config.text ? ' fa-fw' : ''}`;\n        labelNode.appendChild(fontIcon);\n      }\n      if (config.text) {\n        labelNode.appendChild(document.createTextNode(config.text));\n      }\n      node.appendChild(labelNode);\n    }\n    const input = (this.inputNode = document.createElement('input'));\n    node.appendChild(input);\n\n    const deleteBtn = document.createElement('div');\n    deleteBtn.className = 'delete-button';\n    deleteBtn.display = 'inline-block';\n    const deleteIcon = document.createElement('i');\n    deleteIcon.className = 'fa fa-times fa-lg';\n    deleteBtn.appendChild(deleteIcon);\n    node.appendChild(deleteBtn);\n    deleteBtn.onclick = () => {\n      input.value = '';\n      if ('createEvent' in document) {\n        let evt = document.createEvent('HTMLEvents');\n        evt.initEvent('change', false, true);\n        input.dispatchEvent(evt);\n      } else {\n        input.fireEvent('onchange');\n      }\n    };\n\n    if (config.onchange) {\n      this.onchange(config.onchange);\n    }\n    return node;\n  }\n\n  setText(value) {\n    this.input.value = value;\n  }\n\n  onchange(userCallback) {\n    const callback = e => {\n      userCallback(this.inputNode.value, { gantt: this.gantt, event: e });\n    };\n    this.inputNode.onchange = callback;\n    this.inputNode.onkeyup = callback;\n  }\n\n  setId(id) {\n    this.inputNode.id = id;\n  }\n}\n\nInput.defaultClass = 'input-box';\n\nclass ButtonGroup extends Component {\n  constructor(gantt, config) {\n    super(gantt, config);\n    this.selected = null;\n    this.callbacks = [];\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {\n    const node = (this.node = document.createElement('div'));\n    if (config.classes) {\n      node.className = config.classes;\n    }\n    this.buttons = [];\n    Gantt.utils.addClass(node, 'button-group');\n    node.style.display = 'flex';\n    node.style.flexDirection = 'row';\n    node.style.alignItems = 'center';\n\n    const self = this;\n    function installBtnClicked(button) {\n      button.clicked = () => {\n        self.setSelected(button);\n      };\n    }\n\n    this.value = null;\n    let cfgBtns = config.buttons;\n    for (let i = 0; i < cfgBtns.length; ++i) {\n      let btn = new (Gantt.components.Button.impl || Gantt.components.Button)(this.gantt, cfgBtns[i]);\n      this.buttons.push(btn);\n      installBtnClicked(btn);\n      if (cfgBtns[i].selected) {\n        this.selected = btn;\n        btn.setSelected(true);\n        this.value = btn.value;\n      }\n      btn.value = cfgBtns[i].value;\n      node.appendChild(btn.node);\n    }\n    if (config.onchange) {\n      this.onchange(config.onchange);\n    }\n    if (config.value !== undefined) {\n      this.setValue(config.value);\n    }\n    return node;\n  }\n\n  setValue(value, noNotify) {\n    for (let i = 0; i < this.buttons.length; i++) {\n      if (this.buttons[i].value === value) {\n        this.setSelected(this.buttons[i], noNotify);\n        break;\n      }\n    }\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  setSelected(btn, noNotify) {\n    if (this.selected !== btn) {\n      if (this.selected) {\n        this.selected.setSelected(false);\n      }\n      this.selected = btn;\n      if (btn) {\n        this.value = btn.value;\n        btn.setSelected(true);\n      } else {\n        this.value = null;\n      }\n      if (!noNotify) {\n        this.callbacks.map(cb => {\n          cb(this.value);\n        });\n      }\n    }\n  }\n\n  onchange(userCallback) {\n    this.callbacks.push(userCallback);\n  }\n\n  setId(id) {\n    this.inputNode.id = id;\n  }\n}\n\nclass LoadResourceChart extends Component {\n  constructor(gantt, node, config) {\n    super(gantt, node, config);\n    this.node = node;\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {}\n\n  setVisible(visible) {}\n  setScrollLeft(left) {}\n}\n\nclass ConstraintsGraph extends Component {\n  constructor(gantt, node, config) {\n    super(gantt, node, config);\n    this.node = node;\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {}\n  setConstraints(cts) {}\n  setNode(node) {}\n}\n\nclass ConstraintLayout extends Component {\n  constructor(gantt, config) {\n    super(gantt, null, config);\n    this.setConfiguration(config);\n  }\n\n  setConfiguration(config) {}\n  startInitialize() {}\n  addNode(node) {}\n  addConstraint(nodeFrom, nodeTo, cons) {}\n  stopInitialize() {}\n  forEachLink(node, cb) {}\n  layoutNode(node) {}\n  layoutRowNodeLinks(rowIndex) {}\n  drawRowLinks(rowIndex, parentElt, renderer, ctx) {}\n}\n\nGantt.components = {\n  Component,\n  GanttPanel,\n  GanttModel,\n  TreeTable,\n  TimeLine,\n  TimeTable,\n  Split,\n  Tooltip,\n  Filter,\n  DataFetcher,\n  ErrorHandler,\n  Renderer,\n  ActivityLayout,\n  SelectionHandler,\n  LayoutSynchronizer,\n  GanttUpdates,\n  Palette,\n  Toolbar,\n  Button,\n  CheckBox,\n  Toggle,\n  DropDownList,\n  Input,\n  ButtonGroup,\n  LoadResourceChart,\n  ConstraintsGraph,\n  ConstraintLayout,\n};\n\nGantt.envReady = function() {\n  return Promise.resolve(true);\n};\n\nif (module.hot) {\n  module.hot.accept();\n}\n"],"mappings":"AAMA","sourceRoot":""}